from pydantic import BaseModel, Field, HttpUrl
from typing import Optional, List, Literal
from datetime import datetime

# --- Software Component Schemas ---
class SoftwareComponentBase(BaseModel):
    component_type: str = Field(..., description="Type of the component (e.g., 'robot_firmware', 'camera_config', 'plc_program').")
    original_filename: str = Field(..., description="Original name of the uploaded file.")

class SoftwareComponentCreate(SoftwareComponentBase):
    # When creating, we only need type and original filename.
    # The minio_object_key, checksum, file_size will be generated by the service upon upload.
    pass

class SoftwareComponentRead(SoftwareComponentBase):
    id: int
    minio_object_key: str
    checksum: str
    file_size_bytes: int
    upload_timestamp: datetime
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True # For SQLAlchemy 2.0+ orm_mode=True (for older)

# --- Recipe Schemas ---
class RecipeBase(BaseModel):
    name: str = Field(..., min_length=1, description="Name of the individual recipe.")
    product_number: str = Field(..., min_length=1, description="Product number this recipe applies to.")
    recipe_version: str = Field("1.0", description="Version of this specific recipe.")
    instructions: Optional[str] = Field(None, description="Detailed instructions for the recipe (e.g., JSON or text).")

class RecipeCreate(RecipeBase):
    software_components: Optional[List[SoftwareComponentCreate]] = Field(None, description="List of software components to link to this recipe upon creation.")

class RecipeRead(RecipeBase):
    id: int
    recipe_book_id: int
    created_at: datetime
    updated_at: datetime
    software_components: List[SoftwareComponentRead] = [] # Include related components

    class Config:
        from_attributes = True

# --- Recipe Book Schemas ---
class RecipeBookBase(BaseModel):
    name: str = Field(..., min_length=1, description="Unique name of the recipe book.")
    description: Optional[str] = Field(None, description="Description of the recipe book.")
    author: Optional[str] = Field(None, description="Author or creator of the recipe book.")

class RecipeBookCreate(RecipeBookBase):
    major_version: int = Field(1, ge=0, description="Major version number (e.g., 1 for 1.0.0).")
    minor_version: int = Field(0, ge=0, description="Minor version number (e.g., 0 for 1.0.0).")
    # Patch version is managed by the system upon updates within a Major.Minor
    recipes: Optional[List[RecipeCreate]] = Field(None, description="List of recipes to include in this recipe book.")

class RecipeBookUpdate(RecipeBookBase):
    # Allow updating base fields, but versioning logic will be separate for patch/major-minor
    name: Optional[str] = None
    description: Optional[str] = None
    author: Optional[str] = None
    status: Optional[Literal["DRAFT", "APPROVED", "RELEASED", "ARCHIVED"]] = None
    release_date: Optional[datetime] = None

class RecipeBookRead(RecipeBookBase):
    id: int
    major_version: int
    minor_version: int
    patch_version: int
    status: Literal["DRAFT", "APPROVED", "RELEASED", "ARCHIVED"]
    release_date: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    full_version: str # Property from SQLAlchemy model
    recipes: List[RecipeRead] = [] # Include related recipes

    class Config:
        from_attributes = True